yjh 11.11.2007 22:33:53 +0300 - build 334

1. plugin.hpp скорректирован для работы с .c (не .cpp) файлами


t-rex 10.11.2007 23:26:42 +0200 - build 333

1. Правки во врапере по теме нового DialogAPI и около.

2. ViewerInfoW -> ViewerInfo.

yjh 10.11.2007 20:39:24 +0300 - build 332

1. Убран memory leak в GETDLGITEM

2. Добавлен DM_GETREALLOC (для враппера и DialogManager)

3. ВНИМАНИЕ: при получении Item с динамическим буфером
             (IsEdit(Type) && MaxLen==0)
             выделенный буфер (DataOut) должен особождаться плагином


t-rex 10.11.2007 19:11:17 +0200 - build 331

1. Напутал с CutToSlash в 326.

yjh 10.11.2007 18:41:37 +0300 - build 330

1. Изменения в DialogAPI (для нормальной работы с памятью редактируемых
   строк). 
   !!!ВНИМАНИЕ!!! почти все (уже "готовые" плугины надо править)
***
   Краткое описание нового API:
    В FarDialogItem есть 3 поля 
      const wchar_t* DataIn;
      wchar_t* DataOut;
      size_t MaxLen;
    DataIn - задаёт все ВХОДНЫЕ строковые данные (было в DataPtr)
    DataOut - для полей с редактируемоей строкой (см. IsEdit() в pluging.hpp)
              здесь находится указатель на возвращаемые данные.
              для всех остальных типов полей всегда возвращается NULL (см. ниже)
    MaxLen имеет двойное назначение:
       if(MaxLen != 0), то это максимальный размер (включая закрывающий 0)
       ЗАРАНЕЕ выделенного (плугином) буфера указатель на который должен 
       передаваться через DataOut.
       Кроме того, это ограничитель размера для строки ввода (currently not implemented)

       Если же MaxLen==0, то подразумевается, что работа(редактирование) идёт
       со строками с НЕ лимитированным размером. В этом случае в DataOut 
       попадает указатель на динамически выделяемую память (см. ниже) которую
       плугин должен особождать сам.

    В ф-циях FSF.Dialog и FSF.DialogEx добавил ещё один параметр - указатель
    на ф-цию ReAlloc. которая используется Far'ом для аллокации "неограниченных"
    возвращаемых "неограниченных" строк (и освобождения памяти - см. ниже).
    В случае отсуствия в диалоге IsEdit полей, можно передавать NULL.

    При обработке Dialog/DialoEx осуществляется дополнительная проверка 
    параметра DataOut - если MaxLen!=0, то 
       IsBadWritePtr(DataOut,MaxLen*sizeof(wchar_t))
    если же MaxLen==0, то ReAlloc не может быть NULL.
        IsBadReadDataIn должен быть valid read ptr, а DataOut (если Ь

    Если параметр (одного из Item) невалиден, до возвращается -1 БЕЗ исполнения
    диалога.

    Если после "отработки" диалога, при возвращении строк ReAlloc вернёт NULL,
    то будет освобождена вся ранее захваченная им память (через ReAlloc(ptr, 0);)
    и так же возвращена -1.

    При нормальном же завершении Dialog/DialogEx плугин должен сам освободить
    память (все OutPtr) если, конечно, выделял её динамически :)

***

2. Выкинута ф-ция FSF.FreeDialogAnsStr - она теперь не нужна

3. Некоторое (попавшееся по пути :) убирание знаковых целых там где им
   сoвсем не место. По хорошему, надо бы тормознуть все правки и сначала
   навести порядок с этим...

4. Пара ошибок предыдущих патчей обнаруженная в посиках отавшейся ошибки 
   в использовании CutToSlash :)


t-rex 09.11.2007 21:34:19 +0200 - build 329

1. Исправил ещё одни недочёт в АПЙ для x64 версии. Надеюсь что это последний.

t-rex 09.11.2007 18:12:56 +0200 - build 328

1. В UnicodeString::GetBuffer nLength переименован в nSize.

от Alex Alabuzhev:

2. API 1.7:
   a) Control: всё, кроме:
      - в FCTL_GET[ANOTHER]PANELINFO не заполняются поля PanelItems и SelectedItems;
      - не реализован FCTL_SET[ANOTHER]SELECTION, т. к. зависит от предыдущего.
   b) MkLink
   c) GetNumberOfLinks
   d) правильно работает DM_KEY
   e) пропущен break после VCTL_GETINFO в ViewerControl

svs 09.11.2007 15:54:24 +0300 - build 327

1. Mantis#0000352: Undo, вызываемое CTRL+Z не работает если открыть существующий файл на редактирование 
   Проблема в том, что в 1.7x Editor::FreeAllocatedData вызывалась только из деструктора класса Editor.
   В 1.8x эта же функция так же вызывается из FileEditor::LoadFile, при этом массив UndoData удаляется.
   В общем, сделал очередную затычку - новый параметр у Editor::FreeAllocatedData - удалять или очищать
   массив UndoData.
   Для номальной работы (в т.ч. и для реализации Redo) необходимо отказаться от массива в пользу
   двусвязанного списка (или еще чего...)

t-rex 09.11.2007 13:18:53 +0200 - build 326

1. Различные фиксы и улучшения связанные с string.GetBuffer().

2. Немного правок на предмет табы-пробелы в коде.

svs 09.11.2007 11:57:41 +0300 - build 325

1. TVar вынесен в отдельный модуль tvar.?pp + компилятор из macro.cpp в syntax.cpp

2. KeyNameToKey теперь для макроязыка возвращает -1.

3. GetMacroParseError - теперь функция класса Macro.

4. После 2280 пункт 6 отвалился $MMode.
   Теперь $MMode будет компилится по правилам...
   т.е. если раньше было для "$MMode 1":
     0: MCODE_OP_MACROMODE
     1: '1'
   то теперь все встало на свои места:
     0: MCODE_OP_PUSHINT
     1: HIDWORD(1)
     2: LODWORD(1)
     3: MCODE_OP_MACROMODE

5. Mantis#0000351: ACTL_POSTKEYSEQUENCE: пауза при выполнении и лишняя перерисовка 


t-rex 07.11.2007 17:47:14 +0200 - build 324

1. Пару мелких BUGBUG и немного правок на предмет табы-пробелы в коде.

zg 05.11.2007 12:04:08 +0200 - build 323

1. Траблы с...
     > есть 2 макроса 
     > а) в области shell Ctrl-CapsLock=CtrlShiftTab flock(1,2) 
     > б) в области редактора Ctrl-CapsLock=CtrlShiftTab flock(1,2) 
     > 
     > 0. в shell открыли файл в редаторе, переключились снова в shell 
     > 1. нажали Ctrl-CapsLock, у нас таки есть макрос, макрос запускается 
     > 2. макрос отработал, в конце саданул в очередь Up-Down для VK_CAPITAL (тот самый flock(1,2)) 
     > 3. макрос закончился, но: 
     > 3.1 состояние Ctrl - в "нажато" 
     > 3.2 на подходе Up-Down для капслоск 
     > 4. ФАР видит в очереди CtrlCapsLock, проверяет, что мы в редакторе, а там такой же макрос тоже есть - начинает работать макрос 
     > 5. goto п.2 
     > 
     > Помогает только кнопка на морде системного блока 

   исправлено зависание. но так как во время физического нажатия *Lock программно изменить состояние этого самого *Lock нельзя, то макросы надо чуть доработать:
   CtrlCapsLock="CtrlShiftTab %a=flock(1,-1)&1; $while((flock(1,-1)&1)==%a) sleep(50) flock(1,2) $end"

yjh 05.11.2007 05:01:40 +0300 - build 322

1. Для возможности обхода недоделок в API добавлена FSF.FreeDialogAnsStr
   (освобождение памяти аллоцированной ядром для ответа в DI_EDIT).
   Пример использования можно посмотреть в MacroView


t-rex 04.11.2007 22:41:29 +0200 - build 321

1. Исправил пару мелких BUGBUG, в ком строке и запускаторе.

yjh 04.11.2007 22:21:28 +0300 - build 320

1. В FarKeyToName параметр Size и возвращаемое значение в символах, а не
   байтах.

yjh 04.11.2007 21:33:24 +0300 - build 319

1. Добавлена нормальная имплементация FarKeyToName. Изменения в API:
   typedef size_t  (WINAPI *FARSTDKEYTOKEYNAME)(int Key,wchar_t *KeyText,size_t Size);
   Возвращает общий размер (с финальным нулём) скопированный в KeyText.
   Если Size == 0, то возвращает необходимый размер

t-rex 01.11.2007 23:37:35 +0200 - build 318

от chupakabra:

1. При отрисовке рамки вывода информации о панели плагина (Ctrl+L) не используется BoxSymbols[].

t-rex 01.11.2007 22:42:35 +0200 - build 317

от Alex Alabuzhev:

1. API 1.7:
   - ViewerControl
   - еще несколько сообщений Dialog API
   - Text: рекурсия при Str = NULL

svs 01.11.2007 16:57:56 +0300 - build 316

1. Mantis#0000344: Ключи для отключения при запуске макросов / автостартующих макросов
   [+] Добавлены параметры командной строки:
       /m - при старте FAR не будет загружать макросы из реестра
       /ma - при старте ФАР не будет исполнять автостартующие макросы.

2. Падение, если в поисковике файлов в качестве маски указать "*.*, ,*.*"

3. В Хелпе FarEng.hlf.m4 есть русские буковки!
   В очередном патче кто-нить исправьте сей недостаток :-)


t-rex 30.10.2007 20:55:12 +0200 - build 315

от Alex Alabuzhev (с долей исправлений от меня :):
Вообще всё это надо очень хорошо потом протестировать.

1. API 1.7:
   - более-менее рабочий DialogEx.
   - AdvControl.
   - в FARKEYSEQUENCEFLAGS пропущен флаг KSFLAGS_REG_MULTI_SZ

svs 29.10.2007 09:52:31 +0300 - build 314

от _anton_ (?)

1. в plugin.hpp второй параметр у функции MakeDirectoryW char* вместо
   wchar_t*.

t-rex 28.10.2007 21:10:05 +0200

1. Мелкое исправление в EXCEPTION лицензии, неправельный набор слов
   приводил к тому что плагины должны были использовать один или все хидеры
   плагинов а не любой чтоб не попадать под лицензию фара.
   Но полюбому в самих хедерах и так написано что их можно юзать, в LICENSE это
   написано для суммирования.

t-rex 28.10.2007 20:04:06 +0200 - build 313

от Alexandr Zamaraev:

1. Улучшение GCC сборки.

t-rex 28.10.2007 17:59:38 +0200 - build 312

1. По наводке Yurij, в истории редактора\въювера теперь нет ограничения на размер строки,
   ну и за одно падать перестало :).

t-rex 28.10.2007 17:31:13 +0200 - build 311

от Alexandr Zamaraev (Tonal):

1. Сборка под GCC 4.2.1

t-rex 28.10.2007 16:37:51 +0200 - build 310

от Alex Alabuzhev:

1. API 1.7:
   a) Dialog (вроде всё), DialogEx (пока без обработчика) (wrap.cpp)
   b) Menu: пользовательская метка выбора (FarMenuItem.Checked>1) во враппере не перекодировалась
      в юникод (wrap.cpp), глубже тоже были грабли - приводилось к char (vmenu.cpp)

svs 28.10.2007 17:00:58 +0300 - build 

1. Добавлен файл SYSLOG-RU, описывающий элементы логирования в FAR`е

svs 28.10.2007 01:54:39 +0300 - build 309

1. Macro: Падение при записи последовательности с клавиатуры.

2. Вернем обратно KEY_MACRO_BASE в разряд "клавиш".
   Есть проблемы.


svs 28.10.2007 01:15:53 +0300 - build 308

from DrKnS (Alex Alabuzhev): 

1. при выводе плагинового диалога в заголовке консоли был мусор

2. при закрытии некоторых диалогов фар падал из-за неинициализированных переменных.

3. поправлена рамка внизу панели (flshow.cpp).

4. Editor: падала дебажная версия на выходе из редактора после сохранения

5. Editor: неправильно отрезался путь сохр. файла
   
6. Editor: если новый файл и вышли без сохр - UpdateFileList() не вызываем


t-rex 27.10.2007 22:08:48 +0200 - build 307

1. После 301 всплыл глюк с не вытеранием FEDITLINE_CLEARFLAG у Edit контролев.

t-rex 27.10.2007 20:05:33 +0200 - build 306

1. Оптимизация вывода строк редактора на экран, очень ощутимо на очень длинных строках.

2. Убрал SHITHAPPENS за ненадобностью.

t-rex 27.10.2007 17:05:41 +0200 - build 305

от chupakabra:

1. Вход в бесконечный цикл в FarMkTempEx().

2. DeleteFileWithFolder() удаляет только файл и оставляет каталог.

svs 27.10.2007 15:37:28 +0300 - build 304

1. Добавлен MCODE_OP_NOP

2. Уточнения кода по поводу падения во время удаления макроса
   и/или воспроизведенния...


t-rex 27.10.2007 14:18:57 +0200 - build 303

1. Исправил Debug и GCC сборку, и ещё пару варнингов.

svs 27.10.2007 13:15:23 +0300 - build 302

1. Уточнение в KeyMacro::MkTextSequence.

svs 26.10.2007 19:09:24 +0300 - build 301

Поехали....

1. MCODE_OP_EXPR и MCODE_OP_DOIT удалены как класс.

2. KEY_MACRO_BASE ... KEY_MACRO_ENDBASE ужО не "клавиши"!
   Остались только KEY_OP_*, кторые являются "клавишами"

3. В логирование добавлен _MOUSE_EVENT_RECORD_Dump()

4. Изменена SetFLockState
   GetKeyboardState отстой, работает только в дебажной версии (вот ить!)
   вместо нее юзаем нашу GetKeyState()

5. Хмм... а, ну да, оп-коды макросов теперь навинаются с 0
   (небольшое приближение к...)

6. В парсере макросов.
   между MCODE_OP_KEYS и MCODE_OP_ENDKEYS находятся настоящие клавиши!
   сейчас можем наблюдать фигню типа когда parseMacroString() каждую
   "настояшую клавишу" обрамляет этими кода (избыток!), но
   это промежуточный этап....
   В конце будет отдельный DLL, который ФАРу будет отдавать только байткод.

7. В PostNewMacro() добавлен новый параметр...
   предполагается (сейчас!), что плагины "пидалят" макросы с чистыми
   кодами клавиш!
   Но т.к. эта функция испльзуется не только для плагинов, то...
   ...нужно отличать "где мы".

9. Траблы с...
     есть 2 макроса 
     а) в области shell Ctrl-CapsLock=CtrlShiftTab flock(1,2) 
     б) в области редактора Ctrl-CapsLock=CtrlShiftTab flock(1,2) 

     0. в shell открыли файл в редаторе, переключились снова в shell 
     1. нажали Ctrl-CapsLock, у нас таки есть макрос, макрос запускается 
     2. макрос отработал, в конце саданул в очередь Up-Down для VK_CAPITAL (тот самый flock(1,2)) 
     3. макрос закончился, но: 
     3.1 состояние Ctrl - в "нажато" 
     3.2 на подходе Up-Down для капслоск 
     4. ФАР видит в очереди CtrlCapsLock, проверяет, что мы в редакторе, а там такой же макрос тоже есть - начинает работать макрос 
     5. goto п.2 

     Помогает только кнопка на морде системного блока 


t-rex 26.10.2007 14:34:01 +0200 build 300

1. Все готовы? Are you ready? :)
